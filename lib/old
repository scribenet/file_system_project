class FileSystemProject
  attr_reader :path, :name, :subdir, :data_file
  attr_reader :creators, :subjects
  attr_reader :error_log

  def initialize(path, options = {})
    @path = path
    @name = options[:name] ||= File.basename(@path)
    @data_file = File.exist?(@path + '/support/data/data.xml') ? Nokogiri.XML(File.read(@path + '/support/data/data.xml')) : nil
    @error_log = {}
    generate_metadata
    ensure_directory_exists 'support'
  end

  def add_to_error_log(name, error)
    error_log[name] = error
  end

  def self.file_list(type)
    define_method(type + '_files') { list_files(type).map { |i| FileStruct.new i } }
  end

  def self.add_files(type)
    define_method('add_' + type + '_file') do |contents, options|
      ensure_directory_exists type
      name = options[:name]
      File.write @path + "/#{type}/" + name, contents
    end
  end

  FILE_TYPES = %w(docx idtt indd sam scml merged)
  FILE_TYPES.each do |type|
    file_list type
    add_files type
  end

  def list_files(subdir)
    Dir.glob(File.join(path_for(subdir), '*')).sort
  end

  def self.project_path_map(type, second_half)
    define_method('full_' + type + '_path') { path + second_half }
  end

  project_path_map 'epub_input', '/input'
  project_path_map 'support', '/support'
  project_path_map 'data_dir', '/data'

  def self.sub_epub_input_path_map(type, second_half)
    define_method('input_' + type + '_path') { full_epub_input_path + second_half }
  end

  sub_epub_input_path_map 'fonts', '/fonts'
  sub_epub_input_path_map 'images', '/images'
  sub_epub_input_path_map 'css', ''

  def full_output_path
    File.join path, subdir
  end

  def self.sub_epub_output_path_map(type, second_half)
    define_method('full_' + type + '_path') { full_output_path + second_half }
  end

  sub_epub_output_path_map 'epub', '/epub'
  sub_epub_output_path_map 'oebps', '/epub/OEBPS'

  def self.sub_oebps_path_map(type)
    define_method('oebps_' + type + '_path') { full_oebps_path + '/' + type }
  end

  sub_oebps_path_map 'images'
  sub_oebps_path_map 'fonts'

  def static_path
    File.absolute_path(File.dirname ( File.dirname (File.dirname(__FILE__)))) + '/static'
  end

  def path_for(subdir)
    File.join @path, subdir
  end

  def image_files
    Dir.glob(input_images_path + '/*').map { |i| FileStruct.new i }
  end

  def font_files
    Dir.glob(input_fonts_path + '/*').map { |i| FileStruct.new i }
  end

  def css_files
    unless Dir.glob(input_css_path + '/*.css').empty?
      Dir.glob(input_css_path + '/*.css').map { |i| FileStruct.new i }
    else
      [FileStruct.new(File.absolute_path(File.join(__FILE__, '../../../static/default.css')))]
    end
  end

  def cover_image
    image_paths = image_files.map { |img| img.path }
    if image_paths.find { |im| im =~ /input\/images\/#{@name}-cover.[a-z]+$/ }
      return image_paths.find { |im| im =~ /input\/images\/#{@name}-cover.[a-z]+$/ }
    elsif image_paths.find { |im| im =~ /input\/images\/(?!.*back.*).*cover.[a-z]+$/ }
      return image_paths.find { |im| im =~ /input\/images\/(?!.*back.*).*cover.[a-z]+$/ }
    else
      # return "#{@path}/input/images/#{@name}-cover.jpg"
      return ''
    end
  end

  def add_epub_directories(subdir)
    @subdir = subdir
    ensure_directory_exists 'support'
    ensure_directory_exists! File.basename @subdir
    create_dirs
    copy_epub_materials
  end

  def add_oebps_file(contents, options)
    outpath = File.join(full_oebps_path, options[:name])
    File.write outpath, contents
  end

  def add_epub_file(_path, _options)
  end

  def create_dirs
    FileUtils.mkdir_p full_data_dir_path unless File.exist? full_data_dir_path
    FileUtils.mkdir_p full_epub_path unless File.exist? full_epub_path
    FileUtils.mkdir_p full_oebps_path unless File.exist? full_oebps_path
    FileUtils.mkdir_p oebps_fonts_path unless File.exist?(oebps_fonts_path) || font_files.empty?
    FileUtils.mkdir_p oebps_images_path unless File.exist?(oebps_images_path) || image_files.empty?
  end

  def copy_epub_materials
    FileUtils.cp_r(static_path + '/META-INF', full_epub_path)
    FileUtils.cp_r(static_path + '/mimetype', full_epub_path)
    remove_if_empty_directory(input_fonts_path)
    remove_if_empty_directory(input_images_path)
    [
      ['image', oebps_images_path],
      ['font', oebps_fonts_path],
      ['css', full_oebps_path]
    ].each do |type, full_path|
      send(type + '_files').each do |file|
        FileUtils.cp_r(file.path, full_path)
      end
    end
  end

  def remove_if_empty_directory(path)
    if File.directory?(path) and Dir.entries(path).size == 2
      FileUtils.remove_entry_secure(path)
    end
  end

  def ensure_directory_exists(subdir)
    FileUtils.mkdir_p(path_for subdir) unless File.exist? path_for subdir
  end

  def ensure_directory_exists!(subdir)
    FileUtils.remove_entry_secure(path_for subdir) if File.exist? path_for subdir
    ensure_directory_exists subdir
  end

  def remove_empty_directories
    %w(merged sam scml idtt epub epub3).each do |subdir|
      FileUtils.rmdir(path_for subdir) if Dir[path_for subdir + '/*'].empty?
    end
  end

  def make_metadata_accessors(type, default)
    metadata = has_metadata?(type) ? sanitize_metadata(data_file.at_css(type).text) : default
    instance_variable_set('@' + type, metadata)
    singleton_class.class_eval do; attr_reader type.to_sym; end
  end

  def has_metadata?(type)
    data_file and data_file.at_css(type)
  end

  def make_creator_array
    @creators = []
    if data_file.andand.at_css('creator')
      data_file.css('creator').each do |creator|
        @creators << Creator.new(generate_creator_info(creator))
      end
    else
      @creators << Creator.new(role: 'aut', standard: 'PLACEHOLDER', inverse: 'PLACEHOLDER')
    end
  end

  def generate_subjects
    @subjects = []
    if data_file.andand.at_css('subject')
      data_file.css('subject').each do |subj|
        subj_text = sanitize_metadata(subj.text)
        @subjects << Subject.new(full: subj_text)
      end
    else
      @subjects << Subject.new(full: 'Placeholder')
    end
  end

  class Subject
    attr_reader :full
    def initialize(options)
      @full = options[:full]
    end
  end

  class Creator
    attr_reader :role, :standard, :inverse

    def initialize(name_types)
      @role = name_types[:role]
      @standard = name_types[:standard]
      @inverse = name_types[:inverse]
    end
  end

  def generate_creator_info(creator)
    types = [[:role, 'aut'], [:first, 'PLACEHOLDER'], [:middle, ''], [:last, ''], [:suffix, '']]
    names = types.reduce({}){ |names, types|
      type = types[0]
      default = types[1]
      names[type] = creator.at_css(type.to_s).andand.text || default
      names
    }
    standard = make_standard_name names
    inverted = make_inverted_name names
    { role: names[:role], standard: standard, inverse: inverted }
  end

  def make_standard_name(names)
    standard = [:first, :middle, :last].map { |x| names[x] }.join(' ')
    standard += ', ' + names[:suffix] unless names[:suffix].empty?
    standard
  end

  def make_inverted_name(names)
    first_half = names[:last] + ', '
    first_half += names[:suffix] + ', ' unless names[:suffix].empty?
    inverted = first_half + names[:first] + ' ' + names[:middle]
    inverted.gsub(/ $/, '')
  end

  METADATA = [
    %w(projectcode scr-placeholder),
    ['title', 'Placeholder Name'],
    %w(epub_isbn Placeholder),
    %w(mobi_isbn Placeholder),
    %w(publisher Placeholder),
    ['css', 'default.css'],
  ]

  def generate_metadata
    METADATA.each do |type, default|
      make_metadata_accessors type, default
      make_creator_array
      generate_subjects
    end
  end

  def sanitize_metadata(text)
    text = text.gsub(/&/, '&amp;')
    text = text.gsub(/</, '&lt;')
    text = text.gsub(/>/, '&gt;')
  end
end
